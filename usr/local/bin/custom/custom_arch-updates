#!/bin/bash

# 	Filename	:	custom_arch-updates
# 	Type		: 	bash shell script
# 	Author		: 	fkol-k4
# 	Purpose		: 	Arch Linux (+based) system maintenance
# 	Target		: 	Arch-based distribution

#   CLEAR CONSOLE
clear

#   SCRIPT VARIABLES DEFINITION
# 1. Our installation is inside a BTRFS subvolume. We need an extra mountpoint
#    for the system's partition so that we have the ability to manage our 
#    installation's subvolume (snapshot creation and deletion).
#    This mountpoint must have its own /etc/fstab entry.
#    The value below is an example.
ROOT_PARTITION_MOUNTPOINT="/mnt/my-parent-partition"
# 2. The name of the subvolume that our system uses for " / " mountpoint
#    The value below is an example.
SUBVOLUME_NAME="my-subvolume-name"
# 3. We are going to create a GRUB2 entry that will be transfereed to the 
#    /etc/grub.d/ directory of every mounted distribution on the system, in case
#    our PC is dual or multi-booted. The entry's name is defined by the variable
#    set below (naming scheme: 40_custom-$MY_DISTRO_NAME)
#    The value below is an example.
MY_DISTRO_NAME="my-distribution-name"
# 4. The mountpoint list for every distribution that we want to transfer our 
#    GRUB2 entry to. In case the target distribution is installed directly inside
#    a filesystem (ext4 type installation), we need a direct mount point.
#    In case the target distribution is installed inside a BTRFS subvolume, we
#    only need the mountpoint of the partition containing the BTRFS subvolume.
#    Those mountpoints must have their own /etc/fstab entries.
#    The values below are an example.
GRUB_TRANSFER_MOUNTPOINTS="
    /mnt/distribution-X
    /mnt/btrfs-partition-x
    "

#   SNAPSHOTS
#   1. Delete every snapshot except the last one taken.
for i in $(ls $ROOT_PARTITION_MOUNTPOINT/ | sort | grep $SUBVOLUME_NAME-snapshot-on- | head -n -1); do
    sudo btrfs subvolume delete "$ROOT_PARTITION_MOUNTPOINT/$i"
done
#   2. Create a new snapshot
sudo btrfs subvolume snapshot "$ROOT_PARTITION_MOUNTPOINT/$SUBVOLUME_NAME" "$ROOT_PARTITION_MOUNTPOINT/$SUBVOLUME_NAME-snapshot-on-$(date +%Y-%m-%d-%T)"

#   UPDATES
#   1. Update official repository packages
sudo pacman -Syyvu
#   2. Update AUR packages (using Pacaur)
pacaur --check
pacaur --update
#pacaur --update --noconfirm

#   GRUB2 HANDLING
#   1. Update GRUB2 configuration
sudo grub-mkconfig -o /boot/grub/grub.cfg
#   2. Offer GRUB2 installation for every disk on the system
for disk in /dev/sd?; do
    echo -e "
GRUB2 configuration is updated. Do you want to install GRUB2 to disk
\033[1m$disk\033[0m?
Type \033[1my\033[0m to install, or any other key to skip.
Press \033[1mCtrl + C\033[0m to exit this program."
    read -p "Type here: " GRUB_INSTALL_ANSWER
    if [[ $GRUB_INSTALL_ANSWER == y ]]; then
        sudo grub-install --recheck "$disk"
    else
        echo -e "Ok $USER, not touching this disk..."
    fi
done


#   STANDARD MAINTENANCE (comment each loop to disable)
#   1. remove '.goutputstream-*' files from user's home folder
for user_dir in /home/*; do
    rm -f "$user_dir"/.goutputstream-*
done
#   2. unhide xdg startup applications
if [ -d /etc/xdg/autostart ]; then
    sudo sed -i 's/NoDisplay=true/NoDisplay=false/g' /etc/xdg/autostart/*.desktop
fi
#   3. unhide gnome startup applications (if any)
if [ -d /usr/share/gnome/autostart ]; then
    sudo sed -i 's/NoDisplay=true/NoDisplay=false/g' /usr/share/gnome/autostart/*.desktop
fi

#   MAKE A GRUB2 ENTRY FOR ALL OTHER MOUNTED DISTROS
#   Create temporary working directory
mkdir -p /tmp/custom-grub
#   Creating GRUB2 entry
echo '#!/bin/sh
exec tail -n +3 $0
# This file provides an easy way to add custom menu entries.  Simply type the
# menu entries you want to add after this comment.  Be careful not to change
# the <exec tail> line above.
' | sudo tee /tmp/custom-grub/40_custom-$MY_DISTRO_NAME
#   Create the rest of custom grub entry
sudo sed '/### BEGIN \/etc\/grub.d\/10_linux ###/,/### END \/etc\/grub.d\/10_linux ###/!d' /boot/grub/grub.cfg | sudo tee /tmp/custom-grub/stage1
sudo sed '/menuentry/,/### END \/etc\/grub.d\/10_linux ###/!d' /tmp/custom-grub/stage1 | sudo tee -a /tmp/custom-grub/40_custom-$MY_DISTRO_NAME
#   Give custom grub entry executable permissions
sudo chmod +x /tmp/custom-grub/40_custom-$MY_DISTRO_NAME
#   Copy custom grub entry file to all predetermined mount points
for mountpoint in $GRUB_TRANSFER_MOUNTPOINTS/* ; do
    # transfer grub entry if distro is directly mounted on a mountpoint
    if [ -d "$mountpoint/etc/grub.d" ]; then 
        sudo cp "/tmp/custom-grub/40_custom-$MY_DISTRO_NAME" "$mountpoint/etc/grub.d/40_custom-$MY_DISTRO_NAME"
    fi
    for distro in $mountpoint/* ; do
        # transfer grub entry if distro is inside a mountpoint's subvolume
        if [ -d "$mountpoint/$distro/etc/grub.d" ]; then 
            sudo cp "/tmp/custom-grub/40_custom-$MY_DISTRO_NAME" "$mountpoint/$distro/etc/grub.d/40_custom-$MY_DISTRO_NAME"
        fi
    done
done
#   Delete custom grub entry from own /etc/grub.d/ directory
sudo rm -f "/etc/grub.d/40_custom-$MY_DISTRO_NAME"
#   Clear temporary working directory
sudo rmdir --ignore-fail-on-non-empty "/tmp/custom-grub"

#   UPDATES SCRIPT EXIT
#   1. notofy $USER on terminal
echo "    Updates script completed."
echo "    ─────────────────────────"
echo
echo "    The terminal window will remain open for updates inspection.
    Press any key to close it."
#   2. Notify $USER via notification (if possible)
if [[ `which notify-send` ]]; then
    if [ -f /usr/share/icons/custom/donkey.svg ]; then
        notify-send -i /usr/share/icons/custom/donkey.svg -t 3500  "Updates completed. Check your terminal"
    else
        notify-send -t 3500  "Updates completed. Check your terminal"
    fi
fi

# -s: do not echo input character
# -n 1: read only 1 character (separate with space)
read -s -n 1 key
clear
echo "
    Key pressed!

The terminal window will close in four (4) seconds."
echo "
    See you next time" $USER
sleep 4

exit

